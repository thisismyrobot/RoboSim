Basic robot sim
===============

We need a map.

    >>> amap = [[0, 0, 0, 0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 1, 0, 0, 0],
    ...         [0, 0, 0, 0, 1, 0, 0, 0],
    ...         [0, 0, 0, 0, 1, 0, 0, 0],
    ...         [0, 0, 0, 0, 0, 0, 0, 0],
    ...         [0, 0, 0, 0, 0, 0, 0, 0]]

And a robot sim

    >>> import basic
    >>> r = basic.Robot(8, amap, 2, 2)

That now has the map set up

    >>> import pprint
    >>> pp = pprint.PrettyPrinter()
    >>> pp.pprint(r.state)
    [[0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 8, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0]]

Basic movement
--------------

The robot starts facing upwards so will move that way if sent forwards

    >>> r.forward()
    >>> pp.pprint(r.state)
    [[0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 8, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0]]

The robot can turn

    >>> r.turnleft45()
    >>> pp.pprint(r.state)
    [[0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 8, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0]]

    >>> r.forward()
    >>> pp.pprint(r.state)
    [[0, 8, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0]]

Sensors
-------

The robot has sensors that register that the robot is againsts things like
walls - the map edge is a wall. The sensors are at 45 degrees from center on
the front, face on collisions trigger both.

    >>> r.angle
    315

    >>> r._fixangle(r.angle - 45)
    270

    >>> r._fixangle(r.angle + 45)
    0

    >>> r._location(r.x, r.y, 315)
    (0, -1)

    >>> r._location(r.x, r.y, 270)
    (0, 0)

    >>> r._location(r.x, r.y, 0)
    (1, -1)

    >>> r.hit
    [False, True]

    >>> r.turnright45()
    >>> r.hit
    [True, True]

Walls
-----

You can't go through the edge of the map

    >>> r.x, r.y
    (1, 0)

    >>> r.forward()
    >>> r.x, r.y
    (1, 0)

    >>> r.turnright90();
    >>> r.turnright45();
    >>> r.forward()
    >>> r.forward()
    >>> r.x, r.y
    (3, 2)

    >>> r.forward()
    >>> r.x, r.y
    (3, 2)

    >>> r.hit
    [True, True]

    >>> r.turnleft45()
    >>> r.hit
    [False, True]

Simulation
----------

    >>> import random
    >>> random.seed(0)
    >>> locs = []
    >>> for i in range(20):
    ...     hits = r.hit
    ...     if hits[0] and hits[1]:
    ...         r.turn180()
    ...     elif hits[0]:
    ...         r.turnright90()
    ...     elif hits[1]:
    ...         r.turnleft90()
    ...     elif random.random() > 0.75:
    ...         r.turnright45()
    ...     r.forward()
    ...     locs.append((r.x, r.y))

    >>> import copy
    >>> state = copy.deepcopy(r.state)
    >>> state[2][3] = 9
    >>> for i in range(len(locs)):
    ...     x, y = locs[i][0], locs[i][1]
    ...     state[y][x] = 8
    >>> pp.pprint(state)
    [[0, 0, 0, 0, 8, 8, 0, 0],
     [0, 0, 0, 8, 0, 8, 0, 0],
     [0, 0, 0, 9, 0, 8, 8, 8],
     [0, 0, 0, 0, 1, 0, 0, 8],
     [0, 0, 0, 0, 1, 0, 8, 0],
     [0, 0, 0, 0, 1, 8, 0, 0],
     [0, 0, 0, 0, 0, 0, 8, 0],
     [0, 0, 0, 0, 0, 0, 0, 8]]
